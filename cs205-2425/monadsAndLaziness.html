<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<title>monadsAndLaziness</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><a href="index.html">Back to index</a></p>
<h1 id="why-is-io-set-up-this-way-and-some-other-topics.">Why is IO set
up this way and some other topics.</h1>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Array</span> ( (!), array )</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span> ( ord )</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>This question is a good excuse to:</p>
<ul>
<li><p>see how the do notation is actually compiled</p></li>
<li><p>reveal the existence of monads (and demystify the
notion)</p></li>
<li><p>talk some more about lazy evalutation</p></li>
</ul>
<h2
id="desugaring-the-do-notation-recalling-the-context-of-io">Desugaring
the do notation (recalling the context of IO)</h2>
<p>First, let us recall how the do notation for IO is translated to a
bunch of function applications (that is what ghc will do under the
hood).</p>
<p>To translate <em>every</em> instance of the do notation we have seen
so far, we only need one basic function (written as an infix operator
and commonly called ‘bind’)</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">   (&gt;&gt;=) ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span></code></pre></div>
<p>that allows to chain IO inputs. To build some familiarity with this,
let us first consider a simpler sequence operator</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">   (&gt;&gt;) ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span></code></pre></div>
<p>which is defined by</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>     x <span class="op">&gt;&gt;</span> y  <span class="ot">=</span>  x <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> y</span></code></pre></div>
<p>We don’t need to read that definition right now to build intuitions:
<code>x &gt;&gt; y</code> corresponds to performing the action in
<code>x</code>, then the action in <code>y</code> and return the same
result as <code>y</code>.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ioSeqEx ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>ioSeqEx <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;Hi&quot;</span> <span class="op">&gt;&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;Bye&quot;</span></span></code></pre></div>
<p>This is the same as</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ioSeqExDo ::</span> <span class="dt">IO</span> ()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ioSeqExDo <span class="ot">=</span> <span class="kw">do</span> {</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">putStrLn</span> <span class="st">&quot;Hi&quot;</span>;</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">putStrLn</span> <span class="st">&quot;Bye&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>               }</span></code></pre></div>
<p>and in general, any expression of the shape</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>   <span class="kw">do</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>   {</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>      t;</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      u;</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>   }</span></code></pre></div>
<p>for <code>t</code> and <code>u</code> programs of type
<code>IO a</code> (without assignment) is translated to</p>
<pre><code>t &gt;&gt; u &gt;&gt; ...</code></pre>
<p>The more general <code>(&gt;&gt;=)</code> is needed precisely to
handle variable assignments Let’s take a non-trivial example.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span></code></pre></div>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">copycatDo ::</span> <span class="dt">IO</span> ()</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>copycatDo <span class="ot">=</span> <span class="kw">do</span> {</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                  x <span class="ot">&lt;-</span> <span class="fu">getLine</span>;</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">putStrLn</span> (x <span class="op">++</span> <span class="st">&quot;!&quot;</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>               }</span></code></pre></div>
<p>This is equivalent to</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">copycatBind ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>copycatBind <span class="ot">=</span> <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> (x <span class="op">++</span> <span class="st">&quot;!&quot;</span>)</span></code></pre></div>
<p>We are now ready to look at what the first program of the file looks
like when we translate the do notation using these combinators. Recall
that the definition was</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">doIO1 ::</span> <span class="dt">IO</span> <span class="dt">String</span> </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>doIO1 <span class="ot">=</span> <span class="kw">do</span> {</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>             a <span class="ot">&lt;-</span> <span class="fu">getLine</span>;</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>             b <span class="ot">&lt;-</span> <span class="fu">getLine</span>;</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>             <span class="fu">putStrLn</span> (b <span class="op">++</span> a);</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>             <span class="fu">return</span> (b <span class="op">++</span> a)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>           } </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a> </span></code></pre></div>
<p>Now let us look at the equivalent variant using (&gt;&gt;=) and
(&gt;&gt;) and using a suggestive indentation</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">bindIO ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>bindIO <span class="ot">=</span> <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>         <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>         <span class="fu">putStrLn</span> (b <span class="op">++</span> a) <span class="op">&gt;&gt;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>         <span class="fu">return</span> (b <span class="op">++</span> a)</span></code></pre></div>
<p>And that is all that is behind the do notations!</p>
<h2 id="the-do-notation-some-puzzling-examples">The do notation: some
(puzzling) examples</h2>
<p>The do notation as we used it so far for IO</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">doIO ::</span> <span class="dt">IO</span> <span class="dt">String</span> </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>doIO <span class="ot">=</span> <span class="kw">do</span> {</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>            a <span class="ot">&lt;-</span> <span class="fu">getLine</span>;</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>            b <span class="ot">&lt;-</span> <span class="fu">getLine</span>;</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>            <span class="fu">putStrLn</span> (b <span class="op">++</span> a);</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            <span class="fu">return</span> (b <span class="op">++</span> a)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>          } </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="ot">``` But in fact the do notations is also applicable in other contexts!</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="ot"> (What is below is a teaser with two examples, not an explanation)</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="ot">1) do notation for list comprehensions</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="ot">```</span>haskell</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="ot">doList ::</span> [(<span class="dt">Int</span>,<span class="dt">Char</span>)]</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>doList <span class="ot">=</span> <span class="kw">do</span> {</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>              x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>];</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>              y <span class="ot">&lt;-</span> [<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;z&#39;</span>];</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>              <span class="fu">return</span> (x,y)</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- [(x,y) | x &lt;- [1..5], y &lt;- [&#39;a&#39;,&#39;z&#39;]]</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; doList</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- [(1,&#39;a&#39;),(1,&#39;z&#39;),(2,&#39;a&#39;),(2,&#39;z&#39;),(3,&#39;a&#39;),(3,&#39;z&#39;),(4,&#39;a&#39;),(4,&#39;z&#39;),(5,&#39;a&#39;),(5,&#39;z&#39;)]</span></span></code></pre></div>
<ol start="2" type="1">
<li>do notation for chaining Maybe computations</li>
</ol>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">divMaybe ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>divMaybe x <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>divMaybe x y <span class="ot">=</span> <span class="dt">Just</span> (x <span class="ot">`div`</span> y)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ot">doMaybe ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>doMaybe x y z <span class="ot">=</span> <span class="kw">do</span> {</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>                      a <span class="ot">&lt;-</span> divMaybe x y;</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>                      b <span class="ot">&lt;-</span> divMaybe z a;</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>                      <span class="fu">return</span> (a <span class="op">+</span> b)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>                   }</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; doMaybe 1 0 0</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- Nothing</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; doMaybe 1 2 0</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; doMaybe 1 1 0</span></span></code></pre></div>
<h2 id="the-most-general-type-for">The most general type for
(&gt;&gt;=)</h2>
<p>Even for the non-IO examples above such as</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">doList1 ::</span> [(<span class="dt">Int</span>,<span class="dt">Char</span>)]</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>doList1 <span class="ot">=</span> <span class="kw">do</span> {</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>              x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>];</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>              y <span class="ot">&lt;-</span> [<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;z&#39;</span>];</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>              <span class="fu">return</span> (x,y)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>             }</span></code></pre></div>
<p>the translation from the do notation to combinators is the same</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="ot">bindList ::</span> [(<span class="dt">Int</span>,<span class="dt">Char</span>)]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>bindList <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>]    <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>           [<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;z&#39;</span>] <span class="op">&gt;&gt;=</span> \y <span class="ot">-&gt;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>           <span class="fu">return</span> (x, y)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; doList1 == bindList</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- True</span></span></code></pre></div>
<p>This does not tell us however what is the meaning of (&gt;&gt;=) when
applied to things which are not IO. If we ask GHC what is the type of
(&gt;&gt;=) and return, we have</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   (&gt;&gt;=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>These functions are actually methods of the typeclass Monad.</p>
<blockquote>
<p><strong>Side-note</strong>: this typeclass has one feature we have
not encountered yet. The argument m of “Monad m” is not a type, but a
type constructor. (jargon: it has higher kind * -&gt; * instead of the
ground kind * for types)</p>
<ul>
<li><p>Examples of types (kind *): Int, Char, [Int]</p></li>
<li><p>Examples of type constructors of kind * -&gt; *: lists ([_]),
Maybe, IO, Either Int</p></li>
<li><p>Examples of type constructors of kind * -&gt; * -&gt; *: tupling
(<em>,</em>), Either</p></li>
</ul>
</blockquote>
<p>Monad is just one of the many typeclasses defined in Prelude, but it
is such a useful abstraction (in particular because it is used for
IO).</p>
<p>Many type constructors come with a rather natural Monad instance such
as [_] and Maybe which are pretty useful. As we have seen in the
examples, the list monad gives some powerful combinators to implement
list comprehensions. The official definition of the operators
(&gt;&gt;=) and return for lists is the following:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>   <span class="fu">return</span> a <span class="ot">=</span> [a]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>   [] <span class="op">&gt;&gt;=</span> _ <span class="ot">=</span> []</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>   (x <span class="op">:</span> xs) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f x <span class="op">++</span> (xs <span class="op">&gt;&gt;=</span> f)</span></code></pre></div>
<p>The instance Monad Maybe on the other hand gives us combinators to
easily chain computations with a “fail state” represented by Nothing.
return is taken to be</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>   <span class="fu">return</span> <span class="ot">=</span> <span class="dt">Just</span></span></code></pre></div>
<p>and the <code>bind</code> constructor is asked as part of an optional
task for Lab 5 ;) It is also pretty natural to define a primitive</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fail</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>to write very natural programs using the do notation!</p>
<p>There are many more Monad instances in the base library which are
useful for a variety of purposes: for instance, there is a ST that
allows to compute pure functions with a suitable facilities to emulate
“mutable variables” as you would find them in imperative languages.</p>
<p>Much like with any typeclasses, advanced users can also define their
own instances.</p>
<h2 id="why-do-we-need-to-use-a-io-type-constructor-again">Why do we
need to use a IO type constructor again?</h2>
<p>Other major functional programming OCaml does not. Up to syntax and
naming conventions (the following code snippets are fictional!), that
language has</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">     putStrLn ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> ()</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">     getLine ::</span> () <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<p>and a chaining operator</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>     (;)<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>so that</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>   f <span class="ot">=</span> <span class="kw">let</span> z <span class="ot">=</span> <span class="fu">getLine</span> () <span class="kw">in</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> y <span class="ot">=</span> <span class="fu">getLine</span> () <span class="kw">in</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> z;</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>       <span class="dv">10</span></span></code></pre></div>
<p>is a valid program of type Int that performs side-effects along the
way.</p>
<p>So why does Haskell force us to wrap our side-effects inside the IO
monad?</p>
<p>One (slightly disingenuous) answer: because Haskell wants to reflect
that computations that are impure are distinguished at the type-level,
and that is good for programmers!</p>
<p>A stronger reason: because programs in Haskell are lazyly evaluated,
having that design decision would make the order in which operations are
executed highly counter-intuitive. Wrapping impure computations inside
an IO monad actually forces evaluation of commands to be executed in
order.</p>
<p>Example: if we evaluate the program f above eagerly, the instructions
would all be executed in sequence. But if we are lazy and want to obtain
the integer value of f while evaluating as little as possible, it is
possible to do so without performing any input/output action!</p>
<h2 id="defining-your-own-typeclass-instances">Defining your own
typeclass instances</h2>
<p>Here I will declare a new typeclass and we will see how to define
typeclass instances.</p>
<p>The typeclass that I am going to define is going to be called Size
and will simply provide, for every type a such that Size a is defined, a
canonical function a -&gt; Int meant to define the size of the type a.
First, we need to declare that</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Sized</span> a <span class="kw">where</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  size ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>The syntax is
<code>class NameOfTheClass typeParameter1 ... typeParameterN where</code>
followed by type signatures of particular functions called
<em>methods</em> of the typeclass. We can check their actual types, and
see that it corresponds to the declaration above</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; :t size</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- size :: Size a =&gt; a -&gt; Int</span></span></code></pre></div>
<p>Methods can be used to declare new functions sharing those sort of
typeclass constraints</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isBig ::</span> <span class="dt">Sized</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>isBig x <span class="ot">=</span> size x <span class="op">&gt;=</span> <span class="dv">51</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>Now that we have declared the typeclass, now would be a good time to
give some values of size for some datatypes where it makes sense! These
values are called <em>instances</em> and are defined using the following
syntax for base types</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sized</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  size _ <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; isBig True</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sized</span> () <span class="kw">where</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>  size () <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sized</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>  size i <span class="ot">=</span> <span class="dv">64</span> </span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sized</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>  size _ <span class="ot">=</span> <span class="dv">8</span> </span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sized</span> <span class="dt">Integer</span> <span class="kw">where</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>  size <span class="ot">=</span> <span class="fu">ceiling</span> <span class="op">.</span> <span class="fu">log</span> <span class="op">.</span> <span class="fu">fromIntegral</span></span></code></pre></div>
<p>It is possible to declare family of instances which can be
implemented using other typeclass instances: here are a few
examples:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sized</span> a <span class="ot">=&gt;</span> <span class="dt">Sized</span> [a] <span class="kw">where</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  size <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> size</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Sized</span> a, <span class="dt">Sized</span> b) <span class="ot">=&gt;</span> <span class="dt">Sized</span> (a,b) <span class="kw">where</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  size (x,y) <span class="ot">=</span> size x <span class="op">+</span> size y</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; size (&quot;abc&quot;,[&quot;aa&quot;,&quot;noooo&quot;,&quot;please&quot;])</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- 80</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; isBig &quot;aaaaaaaaaaaaaaaa&quot;</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- True</span></span></code></pre></div>
<p>As we have seen above with Monad, typeclasses can also be defined in
more complex situations where we have type families, but the general
principles remain the same.</p>
<h2 id="lazy-vs-eager-evaluation">Lazy vs eager evaluation</h2>
<p>First, let us give a rough idea of one way of picturing the
difference between lazy and eager evaluation. Given a function
application</p>
<pre><code>   (\y -&gt; \x -&gt; (x,x)) (2^5) 2</code></pre>
<p>the lazy evaluator will first try to substitute the arguments in the
function body, delaying the evaluation of the arguments themselves until
the last moment. One way of representing this computation on our example
is</p>
<pre><code>   (\y -&gt; \x -&gt; x+x) (2^12) (2+2)    (initial value)
--    → (\x -&gt; x+1) (2 + 2)          (replace y by the expression 2^5)
--    → (2 + 2) + 1                  (replace x by the expression 2 + 2)
--    → 4 + 1                      
--    → 5                         </code></pre>
<p>Eager evaluators will first evaluate the arguments of their functions
before substituting within the function body.</p>
<pre><code>   (\y -&gt; \x -&gt; x+x) (2^12) (2+2)          (initial value)
      → (\y -&gt; \x -&gt; x+1) 4096 (2 + 2)     (compute 2^5)
      → (\y -&gt; \x -&gt; x+1) 4096 4           (compute 2+2)
      → (\x -&gt; x+1) 4                      (replace y by 4096)
      → 4 + 1                        
      → 5                           </code></pre>
<p>The choice of having lazy evaluation vs eager evaluation can be a
contentious issue in language design; there are pros and cons to
both.</p>
<ul>
<li>Lazy &gt; Eager:
<ul>
<li>lazy evaluation can avoid costly intermediate computations</li>
<li>easier to code recursive functions that terminate in a lazy
setting</li>
</ul></li>
<li>Eager &gt; Lazy:
<ul>
<li>a bit more intuitive to compute the running time</li>
<li>meshes well with IO and imperative programming without a
sophisticated type system</li>
</ul></li>
</ul>
<p>Since we are studying Haskell, which is lazy, I feel it would be best
to leave you with a few examples of laziness in action, some of which
are useful in practice!</p>
<h3
id="laziness-example-1-infinite-intermediate-data-structure">Laziness
example 1: infinite intermediate data structure</h3>
<p>Note that the following declaration is perfectly legal in Haskell,
while it is impossible to do in eager languages such as OCaml (and
analogon that would typecheck would typically loop and crash)</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="ot">allPositiveList ::</span> [<span class="dt">Int</span>]</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>allPositiveList <span class="ot">=</span> <span class="dv">0</span> <span class="op">:</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>) allPositiveList</span></code></pre></div>
<p>Trying to display this using show would lead to an infinite loop. But
thanks to laziness, this can safely be used to compute finitary
data.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; take 10 allPositiveList</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- [0,1,2,3,4,5,6,7,8,9]</span></span></code></pre></div>
<h3 id="laziness-example-2-dynamic-programming">Laziness example 2:
dynamic programming</h3>
<p>Take a good look at the implementation of binomial below. Ignoring
the trivial case where k &gt; n, the main routine uses a local
(immutable) array which seemingly gets initialized with the solution
provided by a recursive function!</p>
<p>This is one elegant of way of doing dynamic programming in Haskell
that is unavailable in languages with eager evaluation. For instance, to
accomplish the same task in OCaml, we would typically need to use
side-effects.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="ot">binomial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>binomial k n <span class="op">|</span> k <span class="op">&gt;</span> n     <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>             <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> a <span class="op">!</span> (k, n)</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">where</span> a <span class="ot">=</span> array ((<span class="dv">0</span>,<span class="dv">0</span>),(k,n))</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>                                 [ ((i,j), b i j) <span class="op">|</span> i <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>k], j <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>n]]</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>                        b <span class="dv">0</span> k <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>                        b i j <span class="op">|</span> i <span class="op">==</span> j <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>                        b i j <span class="ot">=</span> (a <span class="op">!</span> (i,j<span class="op">-</span><span class="dv">1</span>)) <span class="op">+</span> (a <span class="op">!</span> (i<span class="op">-</span><span class="dv">1</span>,j<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; binomial 5 10</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- 252</span></span></code></pre></div>
<h3
id="laziness-example-3-ignoring-some-diverging-computations">Laziness
example 3: ignoring (some) diverging computations</h3>
<p>Compare and contrast the following definitions:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ot">andl ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span> <span class="ot">`andl`</span> _ <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>_ <span class="ot">`andl`</span> <span class="dt">False</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span> <span class="ot">`andl`</span> <span class="dt">True</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="ot">andr ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>_ <span class="ot">`andr`</span> <span class="dt">False</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="dt">False</span> <span class="ot">`andr`</span> _ <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span> <span class="ot">`andr`</span> <span class="dt">True</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="ot">``` Take an ill-founded recursive definition; trying to evaluate this would</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="ot">   not go well! ```</span>haskell</span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a><span class="ot">bot ::</span> a</span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>bot <span class="ot">=</span> bot</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; bot</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- loops forever</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; False `andl` bot</span></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; bot `andl` False</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- loops forever</span></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; bot `andr` False</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span></code></pre></div>
<p><a
href="http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/">Here</a>
are Math-oriented examples (that can be patched to work in an eager
language, but laziness makes definition easier to go through) which are
very fun!</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
<p><a href="index.html">Back to index</a></p>
<footer>
  <a href="https://guide.deuxfleurs.fr/infrastructures/production/">hosted by 2&#127804;</a><br/>
      <a href="https://www.irif.fr/~ledent/">⊲</a> &#128376;&#128141; du <a href="nonConfusedTree.html">&#129382;</a> <a href="https://glitchbra.in">⊳</a>
</footer>
</body>
</html>

<script>
  function randInt(bound){
    return Math.floor(Math.random() * bound);
  }

  var bgColors = ['f9aca2','f9e1a2','b9f9a2','a2a6f9','d5a2f9','f9a2d8','d9dbba'];
  var bgColor = bgColors[randInt(bgColors.length)];
  document.querySelector('body').style.background = '#' + bgColor;
// Oui je n'avais rien de mieux à faire de mon temps, tel que me nourrir.
// Je prends les suggestions pour la palette de couleurs, j'ai fait n'importe
// quoi.
</script>
